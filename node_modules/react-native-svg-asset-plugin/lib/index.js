"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const fse = require('fs-extra');

const path = require('path');

const sharp = require('sharp');

const defaultConfig = {
  cacheDir: '.png-cache',
  scales: [1, 2, 3],
  output: {}
};
const config = loadConfig();

function loadConfig() {
  let metroConfig;

  try {
    metroConfig = require(path.join(process.cwd(), 'metro.config.js'));
  } catch (_unused) {
    metroConfig = {};
  }

  const transformerOptions = metroConfig.transformer || {};
  const svgAssetPluginOptions = transformerOptions.svgAssetPlugin || {};
  return _objectSpread({}, defaultConfig, {}, svgAssetPluginOptions);
} // First run might cause a xmllib error, run safe warmup
// See https://github.com/lovell/sharp/issues/1593


async function warmupSharp(sharp) {
  try {
    await sharp(Buffer.from(`<svg xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" /></svg>`, 'utf-8')).metadata();
  } catch (_unused2) {}

  return sharp;
}

const asyncWarmSharp = warmupSharp(sharp);

async function reactNativeSvgAssetPlugin(assetData) {
  if (assetData.type === 'svg') {
    return convertSvg(assetData);
  } else {
    return assetData;
  }
}

async function convertSvg(assetData) {
  if (assetData.scales.length !== assetData.files.length) {
    throw new Error("Passed scales doesn't match passed files.");
  } else if (assetData.files.length === 0) {
    throw new Error('No files passed.');
  } else if (assetData.files.length > 1) {
    throw new Error('Multiple SVG scales not supported.');
  } else if (assetData.scales[0] !== 1) {
    throw new Error('Scaled SVGs not supported.');
  }

  const inputFilePath = assetData.files[0];
  const inputFileScale = assetData.scales[0];
  const outputDirectory = path.join(assetData.fileSystemLocation, config.cacheDir);
  const outputName = `${assetData.name}-${assetData.hash}`;
  const [imageData, _] = await Promise.all([readSvg(inputFilePath), fse.ensureDir(outputDirectory)]);
  const outputImages = await Promise.all(config.scales.map(imageScale => generatePng(imageData, imageScale / inputFileScale, path.join(outputDirectory, `${outputName}${getScaleSuffix(imageScale)}.png`), config.output)));
  return _objectSpread({}, assetData, {
    fileSystemLocation: outputDirectory,
    httpServerLocation: `${assetData.httpServerLocation}/${config.cacheDir}`,
    width: imageData.metadata.width,
    height: imageData.metadata.height,
    files: outputImages.map(outputImage => outputImage.filePath),
    scales: outputImages.map(outputImage => outputImage.scale),
    name: outputName,
    type: 'png'
  });
}

async function readSvg(inputFilePath) {
  const fileBuffer = await fse.readFile(inputFilePath);
  const warmSharp = await asyncWarmSharp;
  const metadata = await warmSharp(fileBuffer).metadata();
  return {
    buffer: fileBuffer,
    metadata: metadata
  };
}

async function generatePng(inputFile, scale, outputFilePath, outputOptions) {
  if (inputFile.metadata.density === undefined) {
    throw new Error('Input image missing density information');
  }

  const density = inputFile.metadata.density;
  const warmSharp = await asyncWarmSharp;
  await warmSharp(inputFile.buffer, {
    density: density * scale
  }).png(outputOptions).toFile(outputFilePath);
  return {
    filePath: outputFilePath,
    scale: scale
  };
}

function getScaleSuffix(scale) {
  switch (scale) {
    case 1:
      return '';

    default:
      return `@${scale}x`;
  }
}

const assetDataPlugin = reactNativeSvgAssetPlugin;
module.exports = assetDataPlugin;